// TechRix Phase 1: Core JavaScript System

class DeviceCapabilities {
  static isHighEnd() {
    try {
      const cores = navigator.hardwareConcurrency || 2;
      const connection = navigator.connection;
      const slowConnection = connection && 
        ['slow-2g', '2g', '3g'].includes(connection.effectiveType);
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const hasGoodRAM = navigator.deviceMemory ? navigator.deviceMemory >= 4 : true;
      
      return cores >= 4 && 
             !slowConnection && 
             !prefersReduced && 
             window.innerWidth >= 768 &&
             hasGoodRAM;
    } catch (error) {
      console.warn('DeviceCapabilities detection failed:', error);
      return false; // Conservative fallback
    }
  }
  
  static getGlassLevel() {
    if (this.isHighEnd()) return 'advanced';
    if ((navigator.hardwareConcurrency || 2) >= 2) return 'standard';
    return 'minimal';
  }
}

class MotionBudget {
  constructor() {
    this.concurrent = 2;
    this.queue = [];
    this.active = [];
  }
  
  animate(element, keyframes, options = {}) {
    if (!element || this.active.length >= this.concurrent) {
      this.queue.push({ element, keyframes, options });
      return Promise.resolve();
    }
    
    return new Promise((resolve, reject) => {
      try {
        const animation = element.animate(keyframes, {
          duration: 400,
          easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
          fill: 'forwards',
          ...options
        });
        
        this.active.push(animation);
        
        animation.addEventListener('finish', () => {
          this.active = this.active.filter(a => a !== animation);
          this.processQueue();
          resolve(animation);
        });
        
        animation.addEventListener('cancel', () => {
          this.active = this.active.filter(a => a !== animation);
          this.processQueue();
          reject(new Error('Animation cancelled'));
        });
        
      } catch (error) {
        reject(error);
      }
    });
  }
  
  processQueue() {
    if (this.queue.length > 0 && this.active.length < this.concurrent) {
      const { element, keyframes, options } = this.queue.shift();
      this.animate(element, keyframes, options);
    }
  }
  
  clear() {
    this.active.forEach(animation => animation.cancel());
    this.active = [];
    this.queue = [];
  }
}

class PerformanceGuard {
  constructor() {
    this.fpsThreshold = 55;
    this.frameDrops = 0;
    this.frameDropWindow = 60; // Reset after 60 frames
    this.frameCount = 0;
    this.degraded = false;
    this.monitor();
  }
  
  monitor() {
    let lastFrame = performance.now();
    
    const checkFrame = (timestamp) => {
      const fps = 1000 / (timestamp - lastFrame);
      this.frameCount++;
      
      if (fps < this.fpsThreshold) {
        this.frameDrops++;
      }
      
      // Reset frame drops every 60 frames
      if (this.frameCount % this.frameDropWindow === 0) {
        if (this.frameDrops > 10 && !this.degraded) {
          this.degrade();
        } else if (this.frameDrops < 3 && this.degraded) {
          this.restore();
        }
        this.frameDrops = 0;
      }
      
      lastFrame = timestamp;
      requestAnimationFrame(checkFrame);
    };
    
    requestAnimationFrame(checkFrame);
  }
  
  degrade() {
    this.degraded = true;
    document.documentElement.style.setProperty('--glass-blur-primary', '8px');
    document.documentElement.style.setProperty('--glass-blur-secondary', '4px');
    document.documentElement.classList.add('performance-degraded');
    console.warn('PerformanceGuard: Reduced effects due to frame drops');
  }
  
  restore() {
    this.degraded = false;
    document.documentElement.style.setProperty('--glass-blur-primary', '16px');
    document.documentElement.style.setProperty('--glass-blur-secondary', '8px');
    document.documentElement.classList.remove('performance-degraded');
    console.info('PerformanceGuard: Restored effects - performance improved');
  }
}

class RevealAnimations {
  constructor() {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          this.observer.unobserve(entry.target);
        }
      });
    }, { 
      threshold: 0.1,
      rootMargin: '50px'
    });
    
    this.init();
  }
  
  init() {
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => this.observeElements());
    } else {
      this.observeElements();
    }
  }
  
  observeElements() {
    document.querySelectorAll('.fade-in').forEach(el => {
      this.observer.observe(el);
    });
  }
}

// Initialize core system
document.addEventListener('DOMContentLoaded', () => {
  // Set device capability class
  const glassLevel = DeviceCapabilities.getGlassLevel();
  document.documentElement.classList.add(glassLevel);
  
  if (DeviceCapabilities.isHighEnd()) {
    document.documentElement.classList.add('high-end');
  }
  
  // Initialize systems
  window.motionBudget = new MotionBudget();
  window.performanceGuard = new PerformanceGuard();
  window.revealAnimations = new RevealAnimations();
  
  console.info(`TechRix initialized with ${glassLevel} glass level`);
});

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { DeviceCapabilities, MotionBudget, PerformanceGuard, RevealAnimations };
}